package io.mixeway.db.entity;

import org.hibernate.annotations.OnDelete;
import org.hibernate.annotations.OnDeleteAction;
import org.hibernate.annotations.Proxy;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import javax.persistence.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Objects;

@Entity
@EntityScan
@Table(name = "projectvulnerability_aud")
public class ProjectVulnerabilityAudit {

    @EmbeddedId
    private ProjectVulnerabilityAuditId id;
    private int revtype;
    private String inserted;
    private String analysis;
    private String location;
    private String severity;
    private String ticketid;

    @ManyToOne(fetch = FetchType.EAGER, optional = true)
    @JoinColumn(name = "status_id", nullable = true)
    private Status status;

    @ManyToOne(fetch = FetchType.EAGER, optional = true)
    @JoinColumn(name = "vulnerability_id", nullable = true)
    private Vulnerability vulnerability;

    @ManyToOne(fetch = FetchType.EAGER, optional = true)
    @JoinColumn(name = "project_id", nullable = true)
    private Project project;

    @ManyToOne(fetch = FetchType.EAGER, optional = true)
    @JoinColumn(name = "codeproject_id", nullable = true)
    private CodeProject codeProject;

    @ManyToOne(fetch = FetchType.EAGER, optional = true)
    @JoinColumn(name = "webapp_id", nullable = true)
    private WebApp webApp;

    @ManyToOne(fetch = FetchType.EAGER, optional = true)
    @JoinColumn(name = "interface_id", nullable = true)
    private Interface anInterface;

    @ManyToOne(fetch = FetchType.EAGER, optional = true)
    @JoinColumn(name = "vulnerabilitysource_id", nullable = true)
    private VulnerabilitySource vulnerabilitySource;

    public ProjectVulnerabilityAuditId getId() {
        return id;
    }

    public int getRevtype() {
        return revtype;
    }

    public String getInserted() {
        return inserted;
    }

    public String getAnalysis() {
        return analysis;
    }

    public String getLocation() {
        return location;
    }

    public String getSeverity() {
        return severity;
    }

    public Status getStatus() {
        return status;
    }

    public Vulnerability getVulnerability() {
        return vulnerability;
    }

    public Project getProject() {
        return project;
    }

    public CodeProject getCodeProject() {
        return codeProject;
    }

    public WebApp getWebApp() {
        return webApp;
    }

    public Interface getAnInterface() {
        return anInterface;
    }

    public String getTicketid() {
        return ticketid;
    }

    public VulnerabilitySource getVulnerabilitySource() {
        return vulnerabilitySource;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ProjectVulnerabilityAudit that = (ProjectVulnerabilityAudit) o;
        return location.equals(that.location) && vulnerability.equals(that.vulnerability) && project.equals(that.project);
    }

    @Override
    public int hashCode() {
        return Objects.hash(location, vulnerability, project);
    }

    public void mapDate() throws ParseException {
        SimpleDateFormat inputFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        // Definiowanie parsera wyj≈õciowego dla docelowego formatu daty
        SimpleDateFormat outputFormat = new SimpleDateFormat("yyyy-MM-dd");
        Date originalDate = inputFormat.parse(this.inserted);
        this.inserted = outputFormat.format(originalDate);

    }
}
