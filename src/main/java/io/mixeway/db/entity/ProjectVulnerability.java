package io.mixeway.db.entity;

import io.mixeway.config.Constants;
import io.mixeway.domain.service.vulnmanager.VulnTemplate;
import io.mixeway.scanmanager.integrations.burpee.model.Issue;
import io.mixeway.scanmanager.service.bugtracking.BugTrackingService;
import io.mixeway.utils.VulnSource;
import io.mixeway.utils.VulnerabilityModel;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.annotations.OnDelete;
import org.hibernate.annotations.OnDeleteAction;
import org.hibernate.envers.Audited;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import javax.persistence.*;
import java.net.URISyntaxException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

import static org.hibernate.envers.RelationTargetAuditMode.NOT_AUDITED;

/***
 * @author gsiewruk
 */
@Entity
@EntityListeners(AuditingEntityListener.class)
@Table(name = "projectvulnerability", indexes = {
        @Index(columnList = "id", name = "projectvulnerability_index")
})
public class ProjectVulnerability {
    private static final Logger log = LoggerFactory.getLogger(ProjectVulnerability.class);

    @Id
    @SequenceGenerator(name = "projectvulnerability_id_seq",
            sequenceName = "projectvulnerability_id_seq",
            allocationSize = 1)
    @GeneratedValue(strategy = GenerationType.SEQUENCE,
            generator = "projectvulnerability_id_seq")
    private Long id;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "project_id")
    @OnDelete(action = OnDeleteAction.CASCADE)
    @Audited(targetAuditMode = NOT_AUDITED)
    private Project project;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "webapp_id")
    @OnDelete(action = OnDeleteAction.CASCADE)
    @Audited(targetAuditMode = NOT_AUDITED)
    private WebApp webApp;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "codeproject_id")
    @OnDelete(action = OnDeleteAction.CASCADE)
    @Audited(targetAuditMode = NOT_AUDITED)
    private CodeProject codeProject;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "interface_id")
    @OnDelete(action = OnDeleteAction.CASCADE)
    @Audited(targetAuditMode = NOT_AUDITED)
    private Interface anInterface;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "softwarepacket_id")
    @OnDelete(action = OnDeleteAction.CASCADE)
    @Audited(targetAuditMode = NOT_AUDITED)
    private SoftwarePacket softwarePacket;

    @Audited
    private String description;
    private String recommendation;

    @Audited
    private String severity;

    @Audited
    private LocalDateTime inserted;

    @Audited
    private String location;

    @Column(name = "externalid")
    private int externalId;

    @Column(name = "ticketid")
    @Audited
    private String ticketId;

    @ManyToOne(fetch = FetchType.EAGER, optional = true)
    @JoinColumn(name = "status_id", nullable = true)
    @OnDelete(action = OnDeleteAction.CASCADE)
    @Audited(targetAuditMode = NOT_AUDITED)
    private Status status;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "codeprojectbranch_id")
    @OnDelete(action = OnDeleteAction.CASCADE)
    @Audited(targetAuditMode = NOT_AUDITED)
    private CodeProjectBranch codeProjectBranch;

    private LocalDateTime created;

    @Audited
    private String analysis;
    private String port;
    private int grade;

    @ManyToOne(fetch = FetchType.EAGER, optional = false)
    @JoinColumn(name = "vulnerabilitysource_id", nullable = false)
    @OnDelete(action = OnDeleteAction.CASCADE)
    @Audited(targetAuditMode = NOT_AUDITED)
    private VulnerabilitySource vulnerabilitySource;

    @ManyToOne(fetch = FetchType.EAGER, optional = true)
    @JoinColumn(name = "cisrequirement_id", nullable = true)
    @OnDelete(action = OnDeleteAction.CASCADE)
    @Audited(targetAuditMode = NOT_AUDITED)
    private CisRequirement cisRequirement;

    @ManyToOne(fetch = FetchType.EAGER, optional = true)
    @JoinColumn(name = "vulnerability_id", nullable = true)
    @OnDelete(action = OnDeleteAction.CASCADE)
    @Audited(targetAuditMode = NOT_AUDITED)
    private Vulnerability vulnerability;

    public ProjectVulnerability() {
        // Default constructor
    }

    /***
     * Constructor ProjectVulnerability
     *
     * @param source               The source of the vulnerability
     * @param codeProject         The code project
     * @param vulnerability        The vulnerability
     * @param description         Description of the vulnerability
     * @param recommendation      Recommendation for the vulnerability
     * @param severity            Severity of the vulnerability
     * @param port               Port of the vulnerability
     * @param location            Location of the vulnerability
     * @param analysis            Analysis of the vulnerability
     * @param vulnerabilitySource The source of the vulnerability information
     * @param cisRequirement      CIS requirement related to the vulnerability
     * @param codeProjectBranch  The branch of the code project
     * @param <V>                The type of vulnerability source
     */
    public <V extends VulnSource> ProjectVulnerability(V source, CodeProject codeProject, Vulnerability vulnerability, String description,
                                                       String recommendation, String severity, String port, String location, String analysis,
                                                       VulnerabilitySource vulnerabilitySource, CisRequirement cisRequirement, CodeProjectBranch codeProjectBranch) {
        this.location = location;
        if (source instanceof Interface) {
            this.anInterface = (Interface) source;
            this.project = this.anInterface.getAsset().getProject();
            this.location = this.anInterface.getAsset().getName();
        } else if (source instanceof WebApp) {
            this.webApp = (WebApp) source;
            this.project = this.webApp.getProject();
        } else if (source instanceof CodeProject) {
            this.codeProject = (CodeProject) source;
            this.project = this.codeProject.getProject();
        } else if (source instanceof SoftwarePacket) {
            this.softwarePacket = (SoftwarePacket) source;
            this.location = this.softwarePacket.getName();
            this.project = codeProject.getProject();
            this.codeProject = codeProject;
        }
        this.cisRequirement = cisRequirement;
        this.inserted = LocalDateTime.now();
        this.vulnerability = vulnerability;
        this.description = description;
        this.recommendation = recommendation;
        this.severity = severity.toLowerCase();
        this.port = port;
        this.analysis = analysis;
        this.grade = analysis != null && analysis.equals(Constants.FORTIFY_ANALYSIS_EXPLOITABLE) ? 1 : 0; // Simplified conditional
        this.vulnerabilitySource = vulnerabilitySource;
        this.codeProjectBranch = codeProjectBranch;
    }

    /***
     * FOR CICD Mixeway scanner
     *
     * @param codeProject            The code project
     * @param vuln                 The vulnerability
     * @param vulnerabilityModel    The vulnerability model
     * @param softwarePacketVuln  The software packet vulnerability
     * @param vulnerabilitySource The source of the vulnerability information
     * @param codeProjectBranch    The branch of the code project
     */
    public ProjectVulnerability(CodeProject codeProject, Vulnerability vuln, VulnerabilityModel vulnerabilityModel,
                                SoftwarePacket softwarePacketVuln, VulnerabilitySource vulnerabilitySource, CodeProjectBranch codeProjectBranch) {
        this.location = softwarePacketVuln.getName();
        this.codeProject = codeProject;
        this.project = codeProject.getProject();
        this.vulnerability = vuln;
        this.vulnerabilitySource = vulnerabilitySource;
        this.softwarePacket = softwarePacketVuln;
        this.severity = vulnerabilityModel.getSeverity().toLowerCase();
        this.recommendation = vulnerabilityModel.getRecomendations();
        this.description = vulnerabilityModel.getDescription();
        this.codeProjectBranch = codeProjectBranch;
    }

    /***
     * Used for burp loadVulnerabilities
     *
     * @param webApp              WebApp which contains vuln
     * @param issue               Get from burp REST API
     * @param vulnerability        The vulnerability
     * @param vulnerabilitySource The source of the vulnerability information
     */
    public ProjectVulnerability(WebApp webApp, Issue issue, Vulnerability vulnerability, VulnerabilitySource vulnerabilitySource) {
        this.webApp = webApp;
        this.project = webApp.getProject();
        this.vulnerabilitySource = vulnerabilitySource;
        this.description = issue.getDescription();
        this.vulnerability = vulnerability;
        this.severity = StringUtils.capitalize(issue.getSeverity());
        this.location = issue.getOrigin() + issue.getPath();
        this.grade = -1;
    }

    /***
     * Updates information for vulnerability of type OpenSource
     *
     * @param score         The score of the vulnerability
     * @param format        The format of the vulnerability information
     * @param softwarePacket The software packet
     * @param project        The project
     * @param description    The description of the vulnerability
     */
    public void updateOpenSourceVulnInfo(Double score, String format, SoftwarePacket softwarePacket, Project project, String description) {
        this.severity = score >= 0.1 && score <= 3.9 ? Constants.API_SEVERITY_LOW :
                score >= 4.0 && score <= 6.9 ? Constants.API_SEVERITY_MEDIUM :
                        score >= 7.0 && score <= 8.9 ? Constants.API_SEVERITY_HIGH :
                                Constants.API_SEVERITY_CRITICAL;
        this.inserted = LocalDateTime.parse(format, DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS"));
        this.softwarePacket = softwarePacket;
        this.project = project;
        this.description = description;
        this.grade = -1;
    }


    // Getters and setters

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Project getProject() {
        return project;
    }

    public void setProject(Project project) {
        this.project = project;
    }

    public WebApp getWebApp() {
        return webApp;
    }

    public void setWebApp(WebApp webApp) {
        this.webApp = webApp;
    }

    public CodeProject getCodeProject() {
        return codeProject;
    }

    public void setCodeProject(CodeProject codeProject) {
        this.codeProject = codeProject;
    }

    public Interface getAnInterface() {
        return anInterface;
    }

    public void setAnInterface(Interface anInterface) {
        this.anInterface = anInterface;
    }

    public SoftwarePacket getSoftwarePacket() {
        return softwarePacket;
    }

    public void setSoftwarePacket(SoftwarePacket softwarePacket) {
        this.softwarePacket = softwarePacket;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getRecommendation() {
        return recommendation;
    }

    public void setRecommendation(String recommendation) {
        this.recommendation = recommendation;
    }

    public String getSeverity() {
        return severity;
    }

    public void setSeverity(String severity) {
        this.severity = severity;
    }

    public LocalDateTime getInserted() {
        return inserted;
    }

    public void setInserted(LocalDateTime inserted) {
        this.inserted = inserted;
    }

    public String getLocation() {
        return location;
    }

    public void setLocation(String location) {
        this.location = location;
    }

    public int getExternalId() {
        return externalId;
    }

    public void setExternalId(int externalId) {
        this.externalId = externalId;
    }

    public String getTicketId() {
        return ticketId;
    }

    public void setTicketId(String ticketId) {
        this.ticketId = ticketId;
    }

    public Status getStatus() {
        return status;
    }

    public void setStatus(Status status) {
        this.status = status;
    }

    public String getAnalysis() {
        return analysis;
    }

    public void setAnalysis(String analysis) {
        this.analysis = analysis;
    }

    public String getPort() {
        return port;
    }

    public void setPort(String port) {
        this.port = port;
    }

    public int getGrade() {
        return grade;
    }

    public void setGrade(int grade) {
        this.grade = grade;
    }

    public VulnerabilitySource getVulnerabilitySource() {
        return vulnerabilitySource;
    }

    public void setVulnerabilitySource(VulnerabilitySource vulnerabilitySource) {
        this.vulnerabilitySource = vulnerabilitySource;
    }

    public Vulnerability getVulnerability() {
        return vulnerability;
    }

    public void setVulnerability(Vulnerability vulnerability) {
        this.vulnerability = vulnerability;
    }

    public LocalDateTime getCreated() {
        return created;
    }

    public void setCreated(LocalDateTime created) {
        this.created = created;
    }

    public CodeProjectBranch getCodeProjectBranch() {
        return codeProjectBranch;
    }

    public void setCodeProjectBranch(CodeProjectBranch codeProjectBranch) {
        this.codeProjectBranch = codeProjectBranch;
    }

    public CisRequirement getCisRequirement() {
        return cisRequirement;
    }

    public void setCisRequirement(CisRequirement cisRequirement) {
        this.cisRequirement = cisRequirement;
    }

    /***
     * Updates status and Grade for vulnerability
     *
     * @param oldVulns The list of old vulnerabilities
     */
    public void updateStatusAndGrade(List<ProjectVulnerability> oldVulns, VulnTemplate vulnTemplate) {
        if (oldVulns.stream().anyMatch(vuln -> vuln.getVulnerabilitySource().getId().equals(this.getId()) && vuln.getLocation().equals(this.getLocation()) &&
                vuln.getVulnerability().getId().equals(this.getVulnerability().getId()))) {
            this.status = vulnTemplate.STATUS_EXISTING;
            Optional<ProjectVulnerability> infrastructureVuln = oldVulns.stream().filter(vold -> vold.getVulnerability().equals(this.vulnerability) && vold.getDescription().equals(this.getDescription())
                    && vold.getSeverity().equals(this.getSeverity()) && vold.getPort().equals(this.getPort())).findFirst();
            infrastructureVuln.ifPresent(value -> this.setGrade(value.getGrade()));
        } else {
            this.setStatus(vulnTemplate.STATUS_NEW);
        }
        if (this.status.getName().equals(Constants.STATUS_NEW)) {
            this.grade = -1;
        }
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof ProjectVulnerability)) return false;
        ProjectVulnerability other = (ProjectVulnerability) o;
        if (other.externalId > 0) {
            return other.externalId == this.externalId;
        } else if (StringUtils.isNotEmpty(other.location) && other.codeProjectBranch == null) {
            return other.location.equals(this.location) && other.vulnerability.getId().equals(this.vulnerability.getId());
        } else if (StringUtils.isNotEmpty(other.location) && (other.codeProjectBranch != null && this.codeProjectBranch != null)) {
            return other.location.equals(this.location) && other.vulnerability.getId().equals(this.vulnerability.getId()) && other.codeProjectBranch.getId().equals(this.getCodeProjectBranch().getId());
        } else if (other.softwarePacket != null && (other.codeProjectBranch != null && this.codeProjectBranch != null)) {
            return other.softwarePacket.getId().equals(this.softwarePacket.getId()) && other.getVulnerability().getId().equals(this.getVulnerability().getId()) &&
                    this.vulnerabilitySource.getId().equals(other.vulnerabilitySource.getId()) && other.codeProjectBranch.getId().equals(this.getCodeProjectBranch().getId());
        } else if (other.codeProject != null && (other.codeProjectBranch != null && this.codeProjectBranch != null)) {
            return other.codeProject.getId().equals(this.codeProject.getId()) && other.getVulnerability().getId().equals(this.getVulnerability().getId()) &&
                    this.vulnerabilitySource.getId().equals(other.vulnerabilitySource.getId()) && other.location.equals(this.getLocation())
                    && other.codeProjectBranch.getId().equals(this.getCodeProjectBranch().getId());
        } else if (this.vulnerability != null) {
            return other.location.equals(this.location) && (other.vulnerability.getId().equals(this.vulnerability.getId())) &&
                    this.vulnerabilitySource.getId().equals(other.vulnerabilitySource.getId());
        } else {
            return other.location.equals(this.location) && Objects.equals(other.cisRequirement, this.cisRequirement) &&
                    this.vulnerabilitySource.getId().equals(other.vulnerabilitySource.getId());
        }
    }

    @Override
    public final int hashCode() {
        return Objects.hash(description, location, vulnerabilitySource.getName(), vulnerability != null ? vulnerability.getName() : 0);
    }

    @PrePersist
    public void prePersist() {
        this.inserted = LocalDateTime.now();
        this.created = LocalDateTime.now();
        this.severity = StringUtils.capitalize(this.severity);
    }

    @PreUpdate
    public void preUpdate() {
        this.inserted = LocalDateTime.now();
    }

    @PreRemove
    public void removeTicket() throws URISyntaxException {
        BugTrackingService.deleteTicket(this);
    }

    public long calculateDifferenceInDays() {
        return ChronoUnit.DAYS.between(created, inserted);
    }

    public String getCustomSeverity() {
        if (this.vulnerability != null && this.vulnerability.getSeverity() != null) {
            return this.vulnerability.getSeverity();
        } else if (this.cisRequirement != null && this.cisRequirement.getSeverity() != null) {
            return this.cisRequirement.getSeverity();
        } else {
            return this.severity;
        }
    }
}