package io.mixeway.api.protocol.vulnerability;

import com.fasterxml.jackson.annotation.JsonInclude;
import io.mixeway.config.Constants;
import io.mixeway.db.entity.*;
import io.mixeway.utils.VulnSource;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Log4j2
@Getter
@Setter
public class Vuln {

	private Long id;
	private String vulnerabilityName;
	private String type;
	private String severity;
	private String description;
	private String ipAddress;
	private String port;
	private String ipProtocol;
	private String baseURL;
	private String location;
	private String project;
	private String analysis;
	private String hostname;
	private String hostType;
	private String requirementCode;
	private String requirement;
	private String packetName;
	private String dateCreated;
	private String ciid;
	private int grade;
	@JsonInclude(JsonInclude.Include.NON_DEFAULT)
	private String routingDomainName;

	public Vuln() {}

	public <S extends VulnSource> Vuln(ProjectVulnerability projectVulnerability, String hostname, String ipAddress, S target, String type) throws UnknownHostException {
		this.hostname = hostname;
		this.ipAddress = ipAddress;
		this.id = projectVulnerability.getId();
		this.dateCreated = projectVulnerability.getInserted().toString();
		this.severity = projectVulnerability.getVulnerability().getSeverity() == null ? projectVulnerability.getSeverity() : projectVulnerability.getVulnerability().getSeverity();
		this.grade = projectVulnerability.getGrade();

		switch (projectVulnerability.getVulnerabilitySource().getName()) {
			case Constants.VULN_TYPE_OPENSOURCE:
				if (target instanceof CodeProject) {
					CodeProject cp = (CodeProject) target;
					this.location = cp.getName() + " / " + projectVulnerability.getSoftwarePacket().getName();
					this.type = Constants.API_SCANNER_PACKAGE;
					this.vulnerabilityName = projectVulnerability.getVulnerability().getName();
					this.description = Objects.toString(projectVulnerability.getDescription(), "") + "\n\n " + Objects.toString(projectVulnerability.getRecommendation(), "");
					this.project = cp.getName();
					this.ciid = cp.getProject().getCiid();
					this.packetName = projectVulnerability.getSoftwarePacket().getName();
				}
				break;
			case Constants.VULNEARBILITY_SOURCE_GITLEAKS:
			case Constants.VULN_TYPE_SOURCECODE:
			case Constants.VULNEARBILITY_SOURCE_IAC:
				if (target instanceof CodeProject) {
					this.vulnerabilityName = projectVulnerability.getVulnerability().getName();
					this.project = projectVulnerability.getCodeProject().getName();
					this.ciid = projectVulnerability.getCodeProject().getProject().getCiid();
					this.location = projectVulnerability.getLocation();
					this.analysis = projectVulnerability.getAnalysis();
					this.type = Constants.API_SCANNER_CODE;
				}
				break;
			case Constants.VULN_TYPE_WEBAPP:
				if (target instanceof WebApp) {
					this.vulnerabilityName = projectVulnerability.getVulnerability().getName();
					this.description = Objects.toString(projectVulnerability.getDescription(), "Description missing") + "\n\n" + Objects.toString(projectVulnerability.getRecommendation(), "");
					this.baseURL = projectVulnerability.getWebApp().getUrl();
					this.location = projectVulnerability.getLocation();
					this.routingDomainName = projectVulnerability.getWebApp().getRoutingDomain() != null ?
							projectVulnerability.getWebApp().getRoutingDomain().getName().equals("Internet") ?
									projectVulnerability.getWebApp().getRoutingDomain().getName() : "Intranet" :
							projectVulnerability.getWebApp().getPublicscan() ? "Internet" : "Intranet";
					this.ipAddress = getIpAddressFromUrl(projectVulnerability.getWebApp().getUrl());
					this.ciid = projectVulnerability.getWebApp().getProject().getCiid();
					this.port = getPortFromUrl(projectVulnerability.getWebApp().getUrl());
					this.type = Constants.API_SCANNER_WEBAPP;
				}
				break;
			case Constants.VULN_TYPE_NETWORK:
				if (target instanceof Interface) {
					this.vulnerabilityName = projectVulnerability.getVulnerability().getName();
					this.description = Objects.toString(projectVulnerability.getDescription(), "Description missing");
					this.ipAddress = projectVulnerability.getAnInterface().getPrivateip() == null || projectVulnerability.getAnInterface().getPrivateip().isEmpty() ?
							projectVulnerability.getAnInterface().getFloatingip() : projectVulnerability.getAnInterface().getPrivateip();
					this.ciid = projectVulnerability.getAnInterface().getAsset().getProject().getCiid();
					this.routingDomainName = projectVulnerability.getAnInterface().getRoutingDomain() != null ? projectVulnerability.getAnInterface().getRoutingDomain().getName() : "";
					if (projectVulnerability.getPort() != null) {
						this.port = projectVulnerability.getPort().split("/")[0].trim().replace(" ", "");
						this.ipProtocol = projectVulnerability.getPort().split("/")[1].trim().replace(" ", "");
					}
					this.type = Constants.API_SCANNER_OPENVAS;
				}
				break;
			case Constants.VULNEARBILITY_SOURCE_CISBENCHMARK:
				if (target instanceof Interface) {
					this.vulnerabilityName = projectVulnerability.getCisRequirement().getName();
					this.description = projectVulnerability.getDescription();
					this.ipAddress = projectVulnerability.getAnInterface().getPrivateip() == null || projectVulnerability.getAnInterface().getPrivateip().isEmpty() ?
							projectVulnerability.getAnInterface().getFloatingip() : projectVulnerability.getAnInterface().getPrivateip();
					this.ciid = projectVulnerability.getAnInterface().getAsset().getProject().getCiid();
					this.routingDomainName = projectVulnerability.getAnInterface().getRoutingDomain() != null ? projectVulnerability.getAnInterface().getRoutingDomain().getName() : "";
					this.type = Constants.VULNEARBILITY_SOURCE_CISBENCHMARK;
				}
				break;
			case Constants.API_SCANNER_PACKAGE:
				if (target instanceof Asset) {
					this.type = Constants.API_SCANNER_PACKAGE;
					this.vulnerabilityName = projectVulnerability.getVulnerability().getName();
					this.description = Objects.toString(projectVulnerability.getDescription(), "Description missing");
					this.location = ((Asset) target).getName();
					this.project = projectVulnerability.getProject().getName();
					this.ciid = projectVulnerability.getProject().getCiid();
					this.packetName = projectVulnerability.getSoftwarePacket().getName();
				}
				break;
		}
	}

	public String getPortFromUrl(String url) {
		try {
			return url.split(":")[2].split("/")[0];
		} catch (Exception e) {
			log.debug("Port is not visible on {}", url);
			return url.split(":")[0].equals("http") ? "80" : "443";
		}
	}

	public String getIpAddressFromUrl(String url) throws UnknownHostException {
		Pattern p = Pattern.compile("\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}(?:\\/\\d{2})?");
		Matcher m = p.matcher(url);
		try {
			if (m.find()) {
				return m.group(0);
			} else {
				String tmp = url.split("://")[1];
				if (tmp.contains(":")) {
					tmp = tmp.split(":")[0];
				} else if (tmp.contains("/")) {
					tmp = tmp.split("/")[0];
				}
				return InetAddress.getByName(tmp).getHostAddress();
			}
		} catch (Exception e) {
			log.debug("Exception during hostname resolution for {}", url);
			return null;
		}
	}
}