package io.mixeway.domain.service.projectvulnerability;

import io.mixeway.db.entity.*;
import io.mixeway.domain.service.vulnmanager.VulnTemplate;
import io.mixeway.utils.VulnSource;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * @author gsiewruk
 */
@Service
@RequiredArgsConstructor
public class GetProjectVulnerabilitiesService {
    private final VulnTemplate vulnTemplate;

    public List<ProjectVulnerability> getProjectVulnerabilitiesForSource(VulnSource source, String filter) {
        if (source instanceof CodeProject) {
            return vulnTemplate.projectVulnerabilityRepository.findByCodeProjectAndAnalysisNot((CodeProject) source, filter);
        } else if (source instanceof WebApp){
            return vulnTemplate.projectVulnerabilityRepository.findByWebApp((WebApp) source);
        }
        return new ArrayList<>();
    }

    public List<ProjectVulnerability> getProjectVulnerabilitiesForProjectAndSourceAndSeverity(Project project, VulnerabilitySource vulnerabilitySource,List<String> severities){
        return vulnTemplate.projectVulnerabilityRepository.findByProjectAndVulnerabilitySourceAndSeverityInAndStatusNot(project,vulnerabilitySource, severities, vulnTemplate.STATUS_REMOVED);
    }

    public List<ProjectVulnerability> getProjectVulnerablitiesForCodeProject(CodeProject codeProject, String filter) {
        return vulnTemplate.projectVulnerabilityRepository.findByCodeProjectAndAnalysisNot(codeProject,"Not an Issue");
    }

    /**
     * Getting old vulnerabilities for CodeGroup and set status to removed
     *
     * @return List of deleted vulns to set proper status
     */
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public List<ProjectVulnerability> getOldVulnsForGroup(CodeProject codeProject, Status status) {
        List<ProjectVulnerability> tmpVulns = new ArrayList<>(vulnTemplate.projectVulnerabilityRepository.findByCodeProject(codeProject));


        if (tmpVulns.size()>0 && status!=null)
            vulnTemplate.projectVulnerabilityRepository.updateVulnState(tmpVulns.stream().map(ProjectVulnerability::getId).collect(Collectors.toList()),
                    vulnTemplate.STATUS_REMOVED.getId());
        return tmpVulns;
    }

    /**
     * Getting old vulnerabilities for CodeProject, and set status to removed
     *
     * @param codeProject CodeProject to delate vulns for
     * @return List of deleted vulns to set proper status
     */
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public List<ProjectVulnerability> getOldVulnsForCodeProject(CodeProject codeProject){
        List<ProjectVulnerability> codeVulns = vulnTemplate.projectVulnerabilityRepository.findByCodeProjectAndVulnerabilitySource(codeProject, vulnTemplate.SOURCE_SOURCECODE).collect(Collectors.toList());
        if (codeVulns.size() > 0) {
            vulnTemplate.projectVulnerabilityRepository.updateVulnState(codeVulns.stream().map(ProjectVulnerability::getId).collect(Collectors.toList()),
                    vulnTemplate.STATUS_REMOVED.getId());
            codeVulns.forEach(pv -> pv.setStatus(vulnTemplate.STATUS_REMOVED));
        }

        return codeVulns;
    }



    /**
     * Getting old vulnerabilities for CodeProject, and set status to removed
     *
     * @param codeProject CodeProject to delate vulns for
     * @return List of deleted vulns to set proper status
     */
//    @Transactional(propagation = Propagation.REQUIRES_NEW)
    @Transactional
    public List<ProjectVulnerability> getOldVulnsForCodeProjectAndSource(CodeProject codeProject, VulnerabilitySource vulnerabilitySource){
        List<ProjectVulnerability> codeVulns = vulnTemplate.projectVulnerabilityRepository.findByCodeProjectAndVulnerabilitySource(codeProject, vulnerabilitySource).collect(Collectors.toList());
        if (codeVulns.size() > 0) {
            vulnTemplate.projectVulnerabilityRepository.updateVulnState(codeVulns.stream().map(ProjectVulnerability::getId).collect(Collectors.toList()),
                    vulnTemplate.STATUS_REMOVED.getId());
            codeVulns.forEach(pv -> pv.setStatus(vulnTemplate.STATUS_REMOVED));
        }

        return codeVulns;
    }

    /**
     * Getting old vulnerabilities for CodeProject, and set status to removed v3API
     *
     * @param codeProject CodeProject to delate vulns for
     * @return List of deleted vulns to set proper status
     */
//    @Transactional(propagation = Propagation.REQUIRES_NEW)
    @Transactional
    public List<ProjectVulnerability> getOldVulnsForCodeProjectAndSourceForBranch(CodeProject codeProject, VulnerabilitySource vulnerabilitySource, CodeProjectBranch codeProjectBranch){
        List<ProjectVulnerability> codeVulns = vulnTemplate.projectVulnerabilityRepository.findByCodeProjectAndVulnerabilitySourceAndCodeProjectBranch(codeProject, vulnerabilitySource, codeProjectBranch).collect(Collectors.toList());
        if (codeVulns.size() > 0) {
            vulnTemplate.projectVulnerabilityRepository.updateVulnState(codeVulns.stream().map(ProjectVulnerability::getId).collect(Collectors.toList()),
                    vulnTemplate.STATUS_REMOVED.getId());
            codeVulns.forEach(pv -> pv.setStatus(vulnTemplate.STATUS_REMOVED));
        }

        return codeVulns;
    }



}
