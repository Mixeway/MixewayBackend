package io.mixeway.domain.service.projectvulnerability;

import io.mixeway.config.Constants;
import io.mixeway.db.entity.*;
import io.mixeway.db.repository.ProjectVulnerabilityAuditRepository;
import io.mixeway.utils.ProjectAudit;
import io.mixeway.utils.VulnerabiltyAudit;
import lombok.RequiredArgsConstructor;
import org.apache.commons.collections.map.HashedMap;
import org.springframework.stereotype.Service;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class FindProjectVulnerabilityAuditService {

    private final ProjectVulnerabilityAuditRepository projectVulnerabilityAuditRepository;

    public List<VulnerabiltyAudit> getCodeVulnerabilityHistory(CodeProject codeProject, String location, Vulnerability vulnerability){
        List<VulnerabiltyAudit> vulnerabiltyAudits = new ArrayList<>();
        List<ProjectVulnerabilityAudit> projectVulnerabilityAudits = projectVulnerabilityAuditRepository.findByCodeProjectAndLocationAndVulnerability(codeProject,location,vulnerability);
        return mergeEvents(projectVulnerabilityAudits);
    }
    public List<VulnerabiltyAudit> getInterfaceHistory(Interface anInterface, String location, Vulnerability vulnerability){
        List<VulnerabiltyAudit> vulnerabiltyAudits = new ArrayList<>();
        List<ProjectVulnerabilityAudit> projectVulnerabilityAudits = projectVulnerabilityAuditRepository.findByAnInterfaceAndLocationAndVulnerability(anInterface,location,vulnerability);
        return mergeEvents(projectVulnerabilityAudits);
    }
    public List<VulnerabiltyAudit> getWebAppHistory(WebApp webApp, String location, Vulnerability vulnerability){
        List<VulnerabiltyAudit> vulnerabiltyAudits = new ArrayList<>();
        List<ProjectVulnerabilityAudit> projectVulnerabilityAudits = projectVulnerabilityAuditRepository.findByWebAppAndLocationAndVulnerability(webApp,location,vulnerability);
        return mergeEvents(projectVulnerabilityAudits);
    }

    public List<VulnerabiltyAudit> getProjectHistory(Project project){
        List<VulnerabiltyAudit> vulnerabiltyAudits = new ArrayList<>();
        List<ProjectVulnerabilityAudit> projectVulnerabilityAudits = projectVulnerabilityAuditRepository.findByProject(project);

        return mergeEvents(projectVulnerabilityAudits);
    }

    public ProjectAudit getProjectAudit(Project project) throws ParseException {
        List<ProjectVulnerabilityAudit> projectVulnerabilityAudits = projectVulnerabilityAuditRepository.findByProject(project);
        double avgTTR = countAverageTimeToResolve(projectVulnerabilityAudits);
        return new ProjectAudit(
                projectVulnerabilityAudits.stream().filter(pva-> pva.getRevtype() ==0).count(),
                projectVulnerabilityAudits.stream().filter(pva-> pva.getRevtype() ==2).count(),
                avgTTR,
                countPercentOfFixedCriticals(projectVulnerabilityAudits));
    }

    private String countPercentOfFixedCriticals(List<ProjectVulnerabilityAudit> projectVulnerabilityAudits) {
        List<ProjectVulnerabilityAudit> resolved = projectVulnerabilityAudits.stream().filter(pva -> pva.getRevtype() == 2 && pva.getSeverity().equals(Constants.VULN_CRITICALITY_CRITICAL)).collect(Collectors.toList());
        List<ProjectVulnerabilityAudit> critical = projectVulnerabilityAudits.stream().filter(pva -> pva.getRevtype() == 0 && pva.getSeverity().equals(Constants.VULN_CRITICALITY_CRITICAL)).collect(Collectors.toList());
        if (resolved.isEmpty() && critical.isEmpty()){
            return "100 %";
        } else if (resolved.isEmpty()){
            return "0 %";
        } else {
            return ((critical.size() / resolved.size()) * 100) + " %";
        }
    }

    public List<VulnerabiltyAudit> mergeEvents(List<ProjectVulnerabilityAudit> events) {
        List<VulnerabiltyAudit> result = new ArrayList<>();
        VulnerabiltyAudit currentAudit = null;

        for (int i = 0; i < events.size(); i++) {
            ProjectVulnerabilityAudit event = events.get(i);

            if (currentAudit == null) {
                currentAudit = new VulnerabiltyAudit(event, event.getInserted().substring(0, 10), event.getInserted().substring(0, 10), 1);
            } else {
                if (currentAudit.getRevType() == event.getRevtype()) {
                    currentAudit.increaseOccurancies();
                    currentAudit.setEnd(event.getInserted().substring(0, 10));
                } else {
                    result.add(currentAudit);
                    currentAudit = new VulnerabiltyAudit(event, event.getInserted().substring(0, 10), event.getInserted().substring(0, 10), 1);
                }
            }

            if (i == events.size() - 1) {
                result.add(currentAudit);
            }
        }

        return result;
    }
    //TODO
    private double countAverageTimeToResolve(List<ProjectVulnerabilityAudit> projectVulnerabilityAudits) throws ParseException {
        double avg = 0.0;
        int resolvedNumber = 0;
        HashMap<List<ProjectVulnerabilityAudit>, List<ProjectVulnerabilityAudit>> listListHashedMap = new HashMap();
        List<ProjectVulnerabilityAudit> resolved = projectVulnerabilityAudits.stream().filter(pva -> pva.getRevtype() == 2).collect(Collectors.toList());
        for (ProjectVulnerabilityAudit pva : resolved){
            long vulnId = pva.getId().getId();
            List<ProjectVulnerabilityAudit> createForProjectVulns = projectVulnerabilityAudits
                    .stream()
                    .filter(
                            creeatedForProject ->
                                    creeatedForProject.getRevtype() == 0
                                            && Objects.equals(creeatedForProject.getId(), vulnId)).collect(Collectors.toList());
            List<ProjectVulnerabilityAudit> resolvedForProjectVulns = projectVulnerabilityAudits
                    .stream()
                    .filter(
                            creeatedForProject ->
                                    creeatedForProject.getRevtype() == 2
                                            && Objects.equals(creeatedForProject.getId(), vulnId)).collect(Collectors.toList());

            if (!createForProjectVulns.isEmpty() && !resolvedForProjectVulns.isEmpty()) {
                listListHashedMap.put(createForProjectVulns, resolvedForProjectVulns);
            }
        }
        for (Map.Entry<List<ProjectVulnerabilityAudit>, List<ProjectVulnerabilityAudit>> entry : listListHashedMap.entrySet()) {
            resolvedNumber++;
            String start = entry.getKey().stream().findFirst().get().getInserted();
            String end = entry.getValue().stream().reduce((first, second) -> second).get().getInserted();
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            Date startDate = sdf.parse(start);
            Date endDate = sdf.parse(end);
            long differenceInMilliseconds = startDate.getTime() - endDate.getTime();
            long differenceInHours = differenceInMilliseconds / (60 * 60 * 1000);
            avg = avg + differenceInHours;
        }
        return avg / resolvedNumber;
    }
}
