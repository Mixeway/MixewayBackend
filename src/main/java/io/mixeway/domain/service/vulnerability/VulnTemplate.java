package io.mixeway.domain.service.vulnerability;

import io.mixeway.config.Constants;
import io.mixeway.db.entity.*;
import io.mixeway.db.repository.*;
import io.mixeway.integrations.bugtracker.BugTracking;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.net.URISyntaxException;
import java.util.*;
import java.util.stream.Collectors;

/**
 * @author gsiewruk
 */
@Component
public class VulnTemplate {
    public final CreateOrGetVulnerabilityService createOrGetVulnerabilityService;
    public final ProjectVulnerabilityRepository projectVulnerabilityRepository;
    public final VulnerabilitySourceRepository vulnerabilitySourceRepository;
    public final VulnerabilityRepository vulnerabilityRepository;
    public final StatusRepository statusRepository;
    public final CisRequirementRepository cisRequirementRepository;
    private final List<BugTracking> bugTrackings;
    private final BugTrackerRepository bugTrackerRepository;
    public final Status STATUS_NEW;
    public final Status STATUS_EXISTING;
    public final Status STATUS_REMOVED;
    public final VulnerabilitySource SOURCE_NETWORK;
    public final VulnerabilitySource SOURCE_SOURCECODE;
    public final VulnerabilitySource SOURCE_WEBAPP;
    public final VulnerabilitySource SOURCE_OPENSOURCE;
    public final VulnerabilitySource SOURCE_OSPACKAGE;
    public final VulnerabilitySource SOURCE_GITLEAKS;
    public final VulnerabilitySource SOURCE_CISBENCHMARK;
    private static final Logger log = LoggerFactory.getLogger(VulnTemplate.class);
    

    public VulnTemplate(CreateOrGetVulnerabilityService createOrGetVulnerabilityService, ProjectVulnerabilityRepository projectVulnerabilityRepository,
                        VulnerabilitySourceRepository vulnerabilitySourceRepository, StatusRepository statusRepository,
                        VulnerabilityRepository vulnerabilityRepository, CisRequirementRepository cisRequirementRepository,
                        List<BugTracking> bugTrackings, BugTrackerRepository bugTrackerRepository){
        this.bugTrackerRepository = bugTrackerRepository;
        this.bugTrackings = bugTrackings;
        this.statusRepository = statusRepository;
        this.vulnerabilitySourceRepository = vulnerabilitySourceRepository;
        this.createOrGetVulnerabilityService = createOrGetVulnerabilityService;
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.projectVulnerabilityRepository = projectVulnerabilityRepository;
        this.cisRequirementRepository = cisRequirementRepository;
        STATUS_EXISTING = statusRepository.findByName(Constants.STATUS_EXISTING);
        STATUS_NEW = statusRepository.findByName(Constants.STATUS_NEW);
        STATUS_REMOVED = statusRepository.findByName(Constants.STATUS_REMOVED);
        SOURCE_NETWORK = vulnerabilitySourceRepository.findByName(Constants.VULN_TYPE_NETWORK);
        SOURCE_SOURCECODE = vulnerabilitySourceRepository.findByName(Constants.VULN_TYPE_SOURCECODE);
        SOURCE_WEBAPP = vulnerabilitySourceRepository.findByName(Constants.VULN_TYPE_WEBAPP);
        SOURCE_OPENSOURCE = vulnerabilitySourceRepository.findByName(Constants.VULN_TYPE_OPENSOURCE);
        SOURCE_OSPACKAGE = vulnerabilitySourceRepository.findByName(Constants.VULN_TYPE_OSPACKAGE);
        SOURCE_GITLEAKS = vulnerabilitySourceRepository.findByName(Constants.VULNEARBILITY_SOURCE_GITLEAKS);
        SOURCE_CISBENCHMARK = vulnerabilitySourceRepository.findByName(Constants.VULNEARBILITY_SOURCE_CISBENCHMARK);
    }

    public void vulnerabilityPersist(List<ProjectVulnerability> oldTmpVulns, ProjectVulnerability projectVulnerability){
        projectVulnerability.setSeverity(projectVulnerability.getCustomSeverity());
        List<ProjectVulnerability> oldVulnsToKeep = oldTmpVulns.stream()
                .filter(o -> o.equals(projectVulnerability))
                .collect(Collectors.toList());
        if (oldVulnsToKeep.size() >0 ){
            oldVulnsToKeep.forEach(o -> o.setStatus(STATUS_EXISTING));
            projectVulnerabilityRepository.saveAll(oldVulnsToKeep);
        } else {
            projectVulnerability.setStatus(STATUS_NEW);
            projectVulnerability.setGrade(-1);
            projectVulnerabilityRepository.save(projectVulnerability);
        }
    }

    public void vulnerabilityPersistList(List<ProjectVulnerability> oldTmpVulns, List<ProjectVulnerability> projectVulnerabilities) {
        projectVulnerabilities.forEach(vuln -> vuln.setSeverity(vuln.getCustomSeverity()));
        List<ProjectVulnerability> newVulns = new ArrayList<>();
        for (ProjectVulnerability projectVulnerability : projectVulnerabilities){
            List<ProjectVulnerability> oldVulnsToKeep = oldTmpVulns.stream()
                    .filter(o -> o.equals(projectVulnerability))
                    .collect(Collectors.toList());
            if (oldVulnsToKeep.size() >0 ){
                oldVulnsToKeep.forEach(o -> o.setStatus(STATUS_EXISTING));
                oldVulnsToKeep.forEach(projectVulnerabilityRepository::saveAndFlush);

            } else {
                projectVulnerability.setStatus(STATUS_NEW);
                projectVulnerability.setGrade(-1);
                newVulns.add(projectVulnerability);
            }
        }
        projectVulnerabilityRepository.saveAll(newVulns);
    }
    public void processBugTracking(CodeProject codeProject, VulnerabilitySource vulnerabilitySource) throws URISyntaxException {
        List<ProjectVulnerability> projectVulnerabilities = projectVulnerabilityRepository
                .findByCodeProjectAndVulnerabilitySourceAndTicketIdIsNullAndSeverityIn(codeProject, vulnerabilitySource, Collections.singletonList("Critical"));
        Optional<BugTracker> bugTracker = bugTrackerRepository.findByProjectAndVulns(codeProject.getCodeGroup().getProject(), vulnerabilitySource.getName());
        if (SOURCE_OPENSOURCE.equals(vulnerabilitySource)) {
            processOpenSourceIssues(projectVulnerabilities, bugTracker, codeProject);
        } else if (SOURCE_SOURCECODE.equals(vulnerabilitySource)) {
            processSourceCodeIssues(projectVulnerabilities, bugTracker, codeProject);
        } else {
            log.warn("[BugTracker] Unsupported Vulnerability type {}. Check newest version of Mixeway on GitHub.", vulnerabilitySource.getName());
        }
       
    }

    private void processSourceCodeIssues(List<ProjectVulnerability> projectVulnerabilities, Optional<BugTracker> bugTracker, CodeProject codeProject) throws URISyntaxException {
        List<Vulnerability> distinctVulnsNamesForCode = projectVulnerabilities.stream().map(ProjectVulnerability::getVulnerability).distinct().collect(Collectors.toList());
        for (Vulnerability v : distinctVulnsNamesForCode){
            List<ProjectVulnerability> vulnsToIssue = projectVulnerabilities.stream().filter(pv -> pv.getVulnerability().equals(v)).collect(Collectors.toList());
            if (projectVulnerabilities.size() > 0 && bugTracker.isPresent()) {
                for (BugTracking bugTracking : bugTrackings) {
                    if (bugTracking.canProcessRequest(bugTracker.get())) {
                        bugTracking.processRequestMultiVuln(projectVulnerabilityRepository, vulnsToIssue,bugTracker.get(), codeProject.getCodeGroup().getProject(),"SourceCode","Autoaction",false);
                    }
                }
            }
        }
    }

    private void processOpenSourceIssues(List<ProjectVulnerability> projectVulnerabilities, Optional<BugTracker> bugTracker, CodeProject codeProject) throws URISyntaxException {
        List<String> libsWithVulns = projectVulnerabilities.stream().map(ProjectVulnerability::getLocation).distinct().collect(Collectors.toList());
        for (String lib : libsWithVulns) {
            List<ProjectVulnerability> vulnsToIssue = projectVulnerabilities.stream().filter(pv -> pv.getLocation().equals(lib)).collect(Collectors.toList());
            if (projectVulnerabilities.size() > 0 && bugTracker.isPresent()) {
                for (BugTracking bugTracking : bugTrackings) {
                    if (bugTracking.canProcessRequest(bugTracker.get())) {
                        bugTracking.processRequestMultiVuln(projectVulnerabilityRepository, vulnsToIssue,bugTracker.get(), codeProject.getCodeGroup().getProject(),"OpenSource","Autoaction",false);
                    }
                }
            }
        }
    }
}
