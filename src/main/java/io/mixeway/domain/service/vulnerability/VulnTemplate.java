package io.mixeway.domain.service.vulnerability;

import io.mixeway.config.Constants;
import io.mixeway.db.entity.ProjectVulnerability;
import io.mixeway.db.entity.Status;
import io.mixeway.db.entity.VulnerabilitySource;
import io.mixeway.db.repository.ProjectVulnerabilityRepository;
import io.mixeway.db.repository.StatusRepository;
import io.mixeway.db.repository.VulnerabilityRepository;
import io.mixeway.db.repository.VulnerabilitySourceRepository;
import org.springframework.context.annotation.Scope;
import org.springframework.context.annotation.ScopedProxyMode;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * @author gsiewruk
 */
@Component
public class VulnTemplate {
    public final CreateOrGetVulnerabilityService createOrGetVulnerabilityService;
    public final ProjectVulnerabilityRepository projectVulnerabilityRepository;
    public final VulnerabilitySourceRepository vulnerabilitySourceRepository;
    public final VulnerabilityRepository vulnerabilityRepository;
    public final StatusRepository statusRepository;
    public final Status STATUS_NEW;
    public final Status STATUS_EXISTING;
    public final Status STATUS_REMOVED;
    public final VulnerabilitySource SOURCE_NETWORK;
    public final VulnerabilitySource SOURCE_SOURCECODE;
    public final VulnerabilitySource SOURCE_WEBAPP;
    public final VulnerabilitySource SOURCE_OPENSOURCE;
    public final VulnerabilitySource SOURCE_OSPACKAGE;

    public VulnTemplate(CreateOrGetVulnerabilityService createOrGetVulnerabilityService, ProjectVulnerabilityRepository projectVulnerabilityRepository,
                        VulnerabilitySourceRepository vulnerabilitySourceRepository, StatusRepository statusRepository,
                        VulnerabilityRepository vulnerabilityRepository){
        this.statusRepository = statusRepository;
        this.vulnerabilitySourceRepository = vulnerabilitySourceRepository;
        this.createOrGetVulnerabilityService = createOrGetVulnerabilityService;
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.projectVulnerabilityRepository = projectVulnerabilityRepository;

        STATUS_EXISTING = statusRepository.findByName(Constants.STATUS_EXISTING);
        STATUS_NEW = statusRepository.findByName(Constants.STATUS_NEW);
        STATUS_REMOVED = statusRepository.findByName(Constants.STATUS_REMOVED);
        SOURCE_NETWORK = vulnerabilitySourceRepository.findByName(Constants.VULN_TYPE_NETWORK);
        SOURCE_SOURCECODE = vulnerabilitySourceRepository.findByName(Constants.VULN_TYPE_SOURCECODE);
        SOURCE_WEBAPP = vulnerabilitySourceRepository.findByName(Constants.VULN_TYPE_WEBAPP);
        SOURCE_OPENSOURCE = vulnerabilitySourceRepository.findByName(Constants.VULN_TYPE_OPENSOURCE);
        SOURCE_OSPACKAGE = vulnerabilitySourceRepository.findByName(Constants.VULN_TYPE_OSPACKAGE);
    }

    public void vulnerabilityPersistx(List<ProjectVulnerability> oldTmpVulns, ProjectVulnerability projectVulnerability){
        ProjectVulnerability finalProjectVulnerability = projectVulnerability;
        List<ProjectVulnerability> oldVulnsToKeep = oldTmpVulns.stream()
                .filter(o -> o.equals(finalProjectVulnerability))
                .collect(Collectors.toList());
        if (oldVulnsToKeep.size() >0 ){
            oldVulnsToKeep.forEach(o -> o.setStatus(STATUS_EXISTING));
            projectVulnerabilityRepository.saveAll(oldVulnsToKeep);
        } else {
            projectVulnerability.setStatus(STATUS_NEW);
            projectVulnerability.setGrade(-1);
            projectVulnerabilityRepository.save(projectVulnerability);
        }
    }

    public void vulnerabilityPersistList(List<ProjectVulnerability> oldTmpVulns, List<ProjectVulnerability> projectVulnerabilities) {
        List<ProjectVulnerability> newVulns = new ArrayList<>();
        for (ProjectVulnerability projectVulnerability : projectVulnerabilities){
            List<ProjectVulnerability> oldVulnsToKeep = oldTmpVulns.stream()
                    .filter(o -> o.equals(projectVulnerability))
                    .collect(Collectors.toList());
            if (oldVulnsToKeep.size() >0 ){
                oldVulnsToKeep.forEach(o -> o.setStatus(STATUS_EXISTING));
                oldVulnsToKeep.forEach(projectVulnerabilityRepository::saveAndFlush);

            } else {
                projectVulnerability.setStatus(STATUS_NEW);
                projectVulnerability.setGrade(-1);
                newVulns.add(projectVulnerability);
            }
        }
        projectVulnerabilityRepository.saveAll(newVulns);
    }
}
